# Неправильное понимание принципа DRY

Многие почему-то понимают принцип DRY (Don't Repeat Yourself) как требование избегать *дублирования кода*. Но это неправильное понимание, оно слишком узкое.

Рассмотрим пару примеров.
## Пример 1
Пусть имеется некий алгоритм бизнес-логики. Бэкендер закодировал его с использованием языка C#: по некоторой коллекции пробегает цикл `foreach`, формируется новая коллекция типа `List`, для добавления новых элементов используется метод `Add`.

А фронтендер реализовал этот же алгоритм на фронте на языке JavaScript: по коллекции бежит цикл `for/of` или обычный `for`, новая коллекция в виде массива, для добавления элементов используется `push`.

Что мы получили? Эти два фрагмента кода абсолютно не похожи друг на друга, но при этом налицо дублирование (чего?), нарушение DRY.

## Пример 2
В предметной области есть некоторая сущность – пусть, для определённости, это будет "Сотрудник". По какой-то причине (в команде не выстроены процессы проектирования?) два разработчика для этой сущности создали два разных типа: `Employee` и `Worker`.

Что имеется на данный момент? Дублирования кода пока нет совсем, оно появится позже, когда мы в этих типах начнём реализовывать бизнес-логику, но нарушение DRY есть _уже сейчас_.

## Так как же правильно?
Правильное определение принципа DRY: **любое знание должно быть представлено в системе в единственном экземпляре**. И дублирование кода – только частный случай нарушения этого принципа.

## Не могу удержаться
Комментарии в коде – нарушение DRY, потому что одно и то же знание представлено дважды – в коде и в комментарии.

---

_Дедушка Волшебник, 2021-03-11_